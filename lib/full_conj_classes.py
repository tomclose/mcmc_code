import numpy as np
import state as st
import csv
import itertools as it

#http://wiki.python.org/moin/PythonDecoratorLibrary#Memoize
class memoize(dict):
    def __init__(self, func):
        self.func = func

    def __call__(self, *args):
        return self[args]

    def __missing__(self, key):
        result = self[key] = self.func(*key)
        return result

@memoize
def bitsum(x):
    return bin(x).count('1')

#@np.vectorize
#def error_count(x):
   #count = 0
   #while(x > 0):
       #count += 1 if x&3 > 0 else 0
       #x = x >> 2
   #return count

def error_count(x):
    # good up to 20 errors
    r = 3 << np.arange(0, 40, 2)
    return np.sum(np.bitwise_and.outer(r, x)>0, axis=0)

def errors_to_n(state):
    ans = 0
    l = 0
    for i,j in state.qubit_indices:
        ans += (state._array[i,j] << 2*l)
        l += 1
    return ans

def set_state_errors(state, n):
    l = 0
    for i, j in state.qubit_indices:
        # find the bits at position 2*l and 2*l+!
        # counting from the least significant bit
        e = (n & (3 << 2*l)) >> 2*l
        state.set_qubit(i, j, e)
        l += 1
    return state

def stab_action_for_site(state, n):
    """
    Return integer representing the action of the nth stabiliser on the qubits

    The first n**2/4 -1 integers correspond to X stabilisers, the next to the Z.

    The stabilisers are counted as read on a page

    """
    # Zero our state just in case
    set_state_errors(state, 0)
    # Apply the appropriate stabiliser
    indices = state.x_stabiliser_indices[:-1] + state.z_stabiliser_indices[:-1]
    state.apply_stabiliser(*indices[n])
    return errors_to_n(state)

def class_candidate(state, class_n):
    """
    Return an integer representing a state in the error class class_n relative
    to the zero state

    0 <= class_n < 16

    """
    # Zero our state just in case
    set_state_errors(state, 0)
    # Generate class member
    state.change_class(class_n)
    return errors_to_n(state)

def bare_stabiliser_actions(size):
    """
    Returns a numpy array of integers representing error configurations
    generated by action of the bare stabilisers.

    """
    s = st.ToricLattice(size)
    n_bare = size**2/2 - 2
    a = np.zeros(n_bare, dtype='int64')
    for i in range(n_bare):
        a[i] = stab_action_for_site(s, i)
    return a

def composite_stabiliser_action(size, n, bare_stab_actions=None):
    """ Returns the integer representing the error configuration generated
    by applying the stabilisers described by the binary representation of n.

    0 <= n < 2**(size**2/2 - 2)
    """
    if bare_stab_actions is None:
        bare_stab_actions = bare_stabiliser_actions(size)
    bitstr = bin(n)[2:] # change n to binary string
    if n == 0:
        # n = 0 is a special case, as bin(0) = '0b0', which has a leading 0
        m = 0
    else:
        m = len(bitstr)
    max_m = size**2/2 - 2
    if m > max_m:
        raise RuntimeError('n too large, {} !< {}'.format(n, 2**max_m))
    stab = 0
    for i in range(m):
        stab ^= int(bitstr[m-1-i]) * bare_stab_actions[i]
    return stab

def composite_stabiliser_actions(size, bare_stab_actions=None):
    """
    Returns a numpy array of integers representing error configurations
    generated by action of the composite stabilisers.

    """
    if bare_stab_actions is None:
        bare_stab_actions = bare_stabiliser_actions(size)
    n_composites = 2**(size**2/2-2)
    a = np.zeros(n_composites, dtype='int64')
    for i in range(n_composites):
        a[i] = composite_stabiliser_action(size, i, bare_stab_actions)
    return a

def class_candidates(size):
    """
    Returns an array of integers representing a candidates from each of
    the 16 logical error classes.

    """
    s = st.ToricLattice(size)
    a = np.zeros(16, dtype='int64')
    for i in range(16):
        a[i] = class_candidate(s, i)
    return a

def zero_orbit(size):
    return np.bitwise_xor.outer(class_candidates(size), composite_stabiliser_actions(size))


def n_to_syndrome(s, n):
    """
    Returns pairs of stabiliser indices for the stabiliser represented
    by n

    """
    # n = 4:  13 => '1101' => ('001', '101') => ('1001', '0101')
    size = s.L
    strlen = size**2/2 - 2
    # 13 => '001101'
    nstr = bin(n)[2:].zfill(strlen)
    # '001101' => ('001', '101')
    xstr, zstr = nstr[:strlen/2], nstr[strlen/2:]
    # ('001', '101') => ('1001', '0101')
    xstr = xstr + str(xstr.count('1')%2)
    zstr = zstr + str(zstr.count('1')%2)
    # reverse strings to make wrapping onto stabilisers easier
    xzstr = xstr[::-1] + zstr[::-1]
    indices = s.x_stabiliser_indices + s.z_stabiliser_indices
    ans = [ ind for i, ind in enumerate(indices) if xzstr[i] == '1']
    return ans


def error_candidate_for_syndrome(n, size):
    """
    Return an integer representing an error configuration that will give
    rise to the given syndrome

    0 <= n < 2**(n**2/2 - 2)

    """
    state = st.ToricLattice(size)
    synd = n_to_syndrome(state, n)
    state = st.ToricLattice.from_syndrome(size, synd, state)
    return errors_to_n(state)

def syndrome_candidates(size):
    """
    Generates a list of integers representing error configurations
    for each stabiliser

    """
    n_stabs = 2**(size**2/2 - 2)
    a = np.zeros(n_stabs)
    for i in range(n_stabs):
        yield error_candidate_for_syndrome(i, size)

def syndrome_class_orbits(size, start=0, stop=None):
    """
    Generates things of the form
    (synd_n, class_n, np.array([ ..consistent error configs ..]))
    """
    if stop is None:
        stop = 2**(size**2/2-2)
    s = st.ToricLattice(size)
    a = zero_orbit(size)
    for i in range(start, stop):
        e = error_candidate_for_syndrome(i, size)
        error_configs = e ^ a
        for j, row in enumerate(error_configs):
            # assume the classes are in numerical order (they are)
            yield (i, j, row)

def error_dist(orbit):
    dist = {}
    for x in orbit:
        b = int(error_count(x)) # now error_count is vectorized it returns a 0-d array
        try:
            dist[b] += 1
        except KeyError: # first time we've seen it
            dist[b] = 1
    return dist

def hist_row(orbit, max_poss):
    #dist = error_dist(orbit)
    #return [dist.get(i, 0) for i in range(max_poss +1)]
    return np.histogram(error_count(orbit), bins=np.arange(max_poss+2))[0]


def write_hist_file(size, filename=None, start=0, stop=None):
    max_poss = size**2/2
    a = np.zeros(max_poss+3, dtype='int64')
    if filename is None:
        filename = './data/full_hist_{}.csv'.format(size)
    with open(filename, 'wb') as csvfile:
        writer = csv.writer(csvfile)
        for syn, cl, orb in syndrome_class_orbits(size, start, stop):
            a[0:2] = syn, cl
            a[2:] = hist_row(orb, max_poss)
            writer.writerow(a)

def read_hist_file(size, filename=None):
    if filename is None:
        filename = './data/full_hist_{}.csv'.format(size)
    with open(filename, 'rb') as csvfile:
        reader = csv.reader(csvfile)
        return np.array([r for r in reader], dtype='int64')

def hist_array(size):
    max_poss = size**2/2
    a = np.zeros((4**(max_poss), max_poss+3), dtype='int64')
    for i, (syn, cl, orb) in enumerate(syndrome_class_orbits(size)):
        a[i, 0:2] = syn, cl
        a[i, 2:] = hist_row(orb, max_poss)
    return a

def class_probabilities(row_array, p):
    # row_array has format [syndrome, logical_error, count(n_errors = 0), count(n_errors = 1), .... ]
    num_bins, total_errors = np.shape(row_array[:, 2:])
    if p < 0.5: # rules out p = 1
        q = p/(3*(1-p))
        prob_row = (1-p)**(total_errors-1) * q ** np.arange(total_errors)
    else: # p != 0
        q = 3*(1-p)/p
        prob_row = (p/3) **(total_errors-1) * q ** np.arange(total_errors-1, -1, -1)
    class_probs = np.dot(row_array[:, 2:], prob_row)
    results = np.zeros((num_bins, 3))
    results[:, 0:2] = row_array[:, 0:2]
    results[:, 2] = class_probs
    return results

def max_class_probs(row_array, p):
    probs = class_probabilities(row_array, p)
    x = probs[:, 2].reshape((-1, 16))
    return np.max(x, axis = 1)

def success_probability(row_array, p):
    return np.sum(max_class_probs(row_array, p))

def binary_combinations(n, r):
    """ Returns the set of integers with binary representation of length n,
    containing exactly r 1s"""
    return [sum(1<<x for x in c) for c in it.combinations(range(n), r)]

def x_synds_near_zero(n, r):
    """ Returns the synds a distance r from 0.
    Note that this will work for any n, r returning synds in the
    code space. In some cases this won't be appropriate e.g.
    (3, 1) => 0, 1, 2, 4
    but none of these will be right - there are no synds in the code
    space one away from 0. These numbers actually represent the synds
    0000, 1001, 1010 and 1100.
    However we could use these numbers if trying to find the synds
    1 away from (1)001 """
    # (0)000 => (1)000, (0)001, (0)010, (0)100
    # (1)000 => (0)000, (1)001, (1)010, (1)100
    if r == 0:
        return [ 0 ]
    else:
        # combine lists: choose the parity stabiliser, don't choose the parity stabiliser
        return binary_combinations(n, r - 1) + binary_combinations(n, r)


def synds_near_zero(n, r, x_parity, z_parity):
    """ The stabilisers a distance r away from the 0 stabiliser """
    if (x_parity + z_parity + r)%2 != 0:
        return []
    else:
        return [ x + (z<<n) for m in range(x_parity, r+1, 2) for x in x_synds_near_zero(n, m) for z in x_synds_near_zero(n, r-m)]




